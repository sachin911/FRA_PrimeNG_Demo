/// <reference path="../defines.d.ts" />
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t;
    return { next: verb(0), "throw": verb(1), "return": verb(2) };
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var path = require("path");
var fs = require("fs");
var _ = require("lodash");
var temp = require('temp').track();
require('source-map-support').install();
var chai_1 = require("chai");
exports.expect = chai_1.expect;
var webpack = require('webpack');
var BPromise = require('bluebird');
var mkdirp = BPromise.promisify(require('mkdirp'));
var rimraf = BPromise.promisify(require('rimraf'));
var readFile = BPromise.promisify(fs.readFile);
var writeFile = BPromise.promisify(fs.writeFile);
var loaderDir = path.join(process.cwd(), 'dist');
exports.defaultOutputDir = path.join(process.cwd(), 'src', 'test', 'output');
exports.defaultFixturesDir = path.join(process.cwd(), 'src', 'test', 'fixtures');
var defaultOptions = {
    watch: false,
};
function createConfig(conf, _options) {
    if (_options === void 0) { _options = defaultOptions; }
    var options = _.merge({}, defaultOptions, _options);
    var defaultConfig = {
        watch: false,
        output: {
            path: exports.defaultOutputDir,
            filename: '[name].js'
        },
        resolve: {
            extensions: ['.ts', '.tsx', '.js', '.jsx'],
        },
        module: {
            loaders: [
                {
                    test: defaultOptions && defaultOptions.loaderQuery && defaultOptions.loaderQuery.allowJs
                        ? /\.(tsx?|jsx?)/
                        : /\.tsx?/,
                    loader: loaderDir,
                    query: Object.assign({
                        target: 'es6',
                    }, {
                        configFileContent: {
                            exclude: ["*"]
                        }
                    }, options.loaderQuery)
                },
            ],
        },
        plugins: []
    };
    var loader = defaultConfig.module.loaders[0];
    if (options.include) {
        loader.include = (loader.include || []).concat(options.include);
    }
    if (options.exclude) {
        loader.exclude = (loader.exclude || []).concat(options.exclude);
    }
    if (options.watch) {
        defaultConfig.watch = true;
    }
    return _.merge(defaultConfig, conf);
}
exports.createConfig = createConfig;
function chroot(root, foo) {
    return __awaiter(this, void 0, void 0, function () {
        var cwd, result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    cwd = process.cwd();
                    process.chdir(root);
                    return [4 /*yield*/, foo()];
                case 1:
                    result = _a.sent();
                    process.chdir(cwd);
                    return [2 /*return*/, result];
            }
        });
    });
}
exports.chroot = chroot;
function expectSource(source, fragment) {
    chai_1.expect(source.replace(/\s/g, '')).include(fragment.replace(/\s/g, ''));
}
exports.expectSource = expectSource;
function fixturePath(fileName, fixturesDir) {
    if (fixturesDir === void 0) { fixturesDir = exports.defaultFixturesDir; }
    return path.join.apply(path, [fixturesDir].concat(fileName));
}
exports.fixturePath = fixturePath;
function readFixture(fileName, fixturesDir) {
    if (fixturesDir === void 0) { fixturesDir = exports.defaultFixturesDir; }
    var filePath = fixturePath(fileName, fixturesDir);
    return readFile(filePath).then(function (buf) { return buf.toString(); });
}
exports.readFixture = readFixture;
function writeFixture(fileName, text, fixturesDir) {
    if (fixturesDir === void 0) { fixturesDir = exports.defaultFixturesDir; }
    var filePath = fixturePath(fileName, fixturesDir);
    return writeFile(filePath, text);
}
exports.writeFixture = writeFixture;
function touchFile(fileName) {
    return readFile(fileName)
        .then(function (buf) { return buf.toString(); })
        .then(function (source) { return writeFile(fileName, source); });
}
exports.touchFile = touchFile;
function outputFileName(fileName, outputDir) {
    if (outputDir === void 0) { outputDir = exports.defaultOutputDir; }
    return path.join(exports.defaultOutputDir, fileName);
}
exports.outputFileName = outputFileName;
function readOutputFile(fileName, outputDir) {
    if (outputDir === void 0) { outputDir = exports.defaultOutputDir; }
    return readFile(outputFileName(fileName || 'main.js', outputDir)).then(function (buf) { return buf.toString(); });
}
exports.readOutputFile = readOutputFile;
function cleanOutputDir(outputDir) {
    if (outputDir === void 0) { outputDir = exports.defaultOutputDir; }
    return rimraf(outputDir)
        .then(function () { return mkdirp(outputDir); });
}
exports.cleanOutputDir = cleanOutputDir;
function cleanAndCompile(config, outputDir) {
    if (outputDir === void 0) { outputDir = exports.defaultOutputDir; }
    return cleanOutputDir(outputDir)
        .then(function () { return compile(config); });
}
exports.cleanAndCompile = cleanAndCompile;
function compile(config) {
    return new Promise(function (resolve, reject) {
        var compiler = webpack(config);
        compiler.run(function (err, stats) {
            if (err) {
                reject(err);
            }
            else {
                resolve(stats);
            }
        });
    });
}
exports.compile = compile;
function watch(config, cb) {
    var compiler = webpack(config);
    var watch = new Watch();
    var webpackWatcher = compiler.watch({}, function (err, stats) {
        watch.call(err, stats);
        if (cb) {
            cb(err, stats);
        }
    });
    watch.close = webpackWatcher.close;
    return watch;
}
exports.watch = watch;
var Watch = (function () {
    function Watch() {
        this.resolves = [];
    }
    Watch.prototype.call = function (err, stats) {
        this.resolves.forEach(function (resolver) {
            resolver([err, stats]);
        });
        this.resolves = [];
    };
    Watch.prototype.wait = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.resolves.push(resolve);
        });
    };
    return Watch;
}());
exports.Watch = Watch;
var Fixture = (function () {
    function Fixture(text, ext) {
        if (ext === void 0) { ext = '.tsx'; }
        this.text = text;
        var tmpobj = temp.openSync({
            prefix: 'atl-',
            suffix: '.tsx'
        });
        this.fileName = tmpobj.path;
        fs.writeFileSync(this.fileName, text);
    }
    Fixture.prototype.path = function () {
        return this.fileName;
    };
    Fixture.prototype.touch = function () {
        touchFile(this.fileName);
    };
    Fixture.prototype.update = function (updater) {
        var newText = updater(this.text);
        this.text = newText;
        fs.writeFileSync(this.fileName, newText);
    };
    return Fixture;
}());
exports.Fixture = Fixture;
//# sourceMappingURL=utils.js.map